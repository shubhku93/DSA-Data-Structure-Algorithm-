<h1>Array</h1>
<ul>
<li>Data structure is a structure of our code which store data and algorithms is method or operations performed on data.</li>
</ul>
<h3>Array Syntex</h3>
<p>int (variable name) [size] ={num,num};
it store only same type of data.</p>
<h3>Loop in Array</h3>
<pre><code>int arr [5] = {2,4,6,2,8};
  int size = 5;
 for(int i=0; i&lt;size; i++){
   cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;&lt;&lt;endl;
 }
</code></pre>
<h2>Sorting Algorithm</h2>
<ol>
<li>Bubble Sort Algorithm</li>
</ol>
<h4>Problem Statement:</h4>
<p>Given an array of N integers, write a program to implement the Bubble Sorting algorithm.
Find the smallest number in array</p>
<ul>
<li>Example :-</li>
<li>Input : N= 5, array [] ={3,2,5,1,4}</li>
<li>Output : 1,2,3,4,5.</li>
<li>Explain :</li>
</ul>
<h5>Solution :-</h5>
<h6>Approach :</h6>
<p>The Algorithm steps are follow:</p>
<ul>
<li>
<p>First, we will select the range of the unsorted array using loop (say i=0) indicate range from 0 to n-1. Similarly (say i=1) start range from 1 to n-1.</p>
</li>
<li>
<p>we will iterate each element and check if adjacent element smaller than swap them.</p>
</li>
<li>
<p>Dry Run :
Iteration 1 :</p>
</li>
</ul>
<pre><code>// Bubble Sort
void bubblesort(vector&lt;int&gt; &amp;v){
  int n= v.size();
    // Outer loop to iterate each element
  for(int i=0; i&lt;n; i++){
      // Inner Loop compare each with adjacent element 
    for(int j=0; j&lt;n; j++){
    // Check if adjacent element is smaller than swap them.
      if(v[j]&gt;v[j+1])
        swap(v[j],v[j+1]);
    }
  }
  for(int i=0; i&lt;n; i++){
    cout&lt;&lt;v[i];
  }
}
</code></pre>
<ol start="2">
<li>Selection Sort Algorithm</li>
</ol>
<pre><code>void select (vector&lt;int&gt; &amp;v,int n){
    for(int i=0; i&lt;n; i++){
       // Assign ith element as smallest in min
        int min=i;
        for(int j=i+1; j&lt;n; j++){
            // check if jth element is smaller than min assign jth index to min
           if(v[j]&lt;v[min]){
               min=j;
           }   
            }
        // Then Swap ith element with min index.
        swap(v[i],v[min]);
            }
    for(int i: v){
        cout&lt;&lt; i;
    }
    }
</code></pre>
<ol start="3">
<li>Insertion Sort Algorithm</li>
</ol>
<pre><code>void insert(vector&lt;int&gt; &amp;v,int n){
    // Loop start from second element 
    for(int i=1; i&lt;n; i++){
        // Store the current element as curr
        int curr= v[i];
        // take first element as sorted array 
        int prev= i-1;
        // Check if prev is greter or equal to 0 and compare prev element is greater than curr then swift the prev element to next position until prev is less than curr or prev is less than 0
        while(prev&gt;=0 &amp;&amp; v[prev]&gt;curr){
            v[prev+1]= v[prev];
            prev--;
        }
        // Insert the curr element at the correct position.
        v[prev+1]= curr;
    }
    for(int i: v) cout&lt;&lt;i&lt;&lt;&quot; &quot;;
}

</code></pre>
<ol start="4">
<li>Quick Sort Algorithm</li>
</ol>
<pre><code>int partition(vector&lt;int&gt; &amp;v, int st, int end) {
    // This function takes last element as pivot and places the pivot element at its correct position in sorted array, and places all smaller to the left of pivot and all greater element to the right of pivot
    int pivot = v[end];
    int i = st - 1;//Index of the smaller element 
    // Traverse through all elements 
    for (int j = st; j &lt; end; j++) {
       // If element smaller than pivot is found, swap it with 
        if (v[j] &lt;= pivot) {
            i++;
            swap(v[i], v[j]);
        }
    }
    swap(v[i + 1], v[end]);
    return i + 1;
}

void quicksort(vector&lt;int&gt; &amp;v, int st, int end) {
    if (st &lt; end) {
        int part = partition (v, st, end);
        quicksort(v, st, part - 1);
        quicksort(v, part + 1, end);
    }
}

</code></pre>
<ol start="5">
<li>Merge Sort Algorithm</li>
</ol>
<pre><code>void merge(vector&lt;int&gt; &amp;v, int st, int mid, int end) {
    vector&lt;int&gt; temp;
    int left = st, right = mid + 1;
    
    while (left &lt;= mid &amp;&amp; right &lt;= end) {
        if (v[left] &lt;= v[right]) {
            temp.push_back(v[left++]);
        } else {
         temp.push_back(v[right++]);
        }
    }
    
    while (left &lt;= mid) {
        temp.push_back(v[left++]);
while (right &lt;= end) {
        temp.push_back(v[right++]);
    }
    
    for (int i = 0; i &lt; temp.size(); i++) {
        v[st + i] = temp[i];
    }
}

void mergesort(vector&lt;int&gt; &amp;v, int st, int end) {
    if (st &gt;= end) return;
    
    int mid = st + (end - st) / 2;
    mergesort(v, st, mid);
    mergesort(v, mid + 1, end);
    merge(v, st, mid, end);
}
</code></pre>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main(){
  int arr [5] = {-145,4,6,2,8};
  int size = 5;
  int smallest=arr[0];
 for(int i=0; i&lt;size; i++){
   if(arr[i]&lt;smallest){
     smallest= arr[i];
   }
   //second way to find small number 
  // smallest=min(smallest,arr[i]);
   
 }
  cout&lt;&lt;smallest;
  return 0;
}
</code></pre>
<details>
<!--Easy Problem of Array-->
<summary><h3> Easy Problem</h3></summary>
<!-- Find Largest Element-->  
<div><details>
<summary> <h4> Largest Element in a Array </h4></summary>
<h5>Problem Statement: </h5> Given an array you have to find the largest element in the array
<!--Examples-->
<details>
<summary> Examples</summary>
<h5>Example 1:</h5>
Input: arr[] = {2,5,1,3,0};
Output: 5
Explanation: 5 is the largest element in the array. 
<h5>Example2:</h5>
Input: arr[] = {8,10,5,7,9};
Output: 10
Explanation: 10 is the largest element in the array.</details>
 <!--Brute Force Approach-->  
<details> <summary>Brute Force Approach </summary>
<!--Approach-->
<details> 
<summary> Approach</summary>
Solution1: Sorting
<h3> Intuition:</h3>
We can sort the array in ascending order, hence the largest element will be at the last index of the array. 
<h3>Approach: </h3>
Sort the array in ascending order.
Print the (size of the array -1)th index.
DryRun: 
Before sorting: arr[] = {2,5,1,3,0};
<p>After sorting: arr[] = {0,1,2,3,5};</p>
<p>Hence answer : arr[sizeofthearray-1] =5</p>
  </details>
<!--Code-->  
<details>
<summary>Code</summary>
  <code>
  </code>
</details>
<!--Complexity Analysis-->
<details>
<summary>Complexity Analysis</summary>
Time Complexity: O(N*log(N))
Space Complexity: O(n)
  </details>
  </details>
   <details>
    <summary> Optimise Approach</summary>
  <details>
      <summary> Approach/Institution</summary>
    Solution2:Using a max variable
<h3>Intuition: </h3>
We can maintain a max variable that will update whenever the current value is greater than the value in the max variable.  
<h3>Approach:</h3>
Create a max variable and initialize it with arr[0].
Use a for loop and compare it with other elements of the array
If any element is greater than the max value, update max value with the element’s value
Print the max variable.
  </details>
  <details>
   <summary> Code</summary>
    <code>
<p></code></p>
  </details>
  <details>
  <summary> Complexity Analysis</summary>
    Time Complexity: O(N)
<p>Space Complexity: O(1)</p>
  </details>
  </details>
  </div>
<!-- Second Largest element-->
<div>
  <details>
    <summary>Second Largest Element in a Array without Sorting</summary>
    <h5> Problem Statement: </h5>Given an array, find the second smallest and second largest element in the array. Print ‘-1’ in the event that either of them doesn’t exist.  
    <detail>
      <summary>Examples</summary>
      <h5> Example 1: </h5>
      Input: [1,2,4,7,7,5]
      Output: Second Smallest=2
       Second Largest=5
      Explaination: Element are as follow 1,2,4,5,7,7 and hence the second Largest element of these is 5 and the second Smallest is 2.
    </detail>
    <detail>
      <summary>Brute Force Approach</summary>
</div>
<!--Array is sorted or not-->
<div>
<details>
    <summary><h3>Array is sorted or not</h3> </summary>
<!--Exlample-->
<details>
    <summary><h5>Examples</h5></summary>
</details>
<!--Brute Force Approach-->
<details>
<summary>Brute Force Approach</summary>
<!--Approach-->
<details>
<summary>Approach/Intuition</summary>
</details>
<!--Dry Run-->
  <details>
  <summary>Dry Run</summary>
  </details>
<!--Code-->
<details>
  <summary>Code</summary>
</details>
<!--Complexity Analysis --><details>
  <summary> Complexity Analysis</summary>
</details>
</details>
<!--Optimise Approach -->
<details>
<summary>Optimization</summary>
<!--Approach/Institution--><details>
<summary> Approach/Institution</summary>
 </details>
<!--Dry Run-->
<details>
<summary>
Dry Run</summary>
</details>
<!--Code-->
<details>
  <summary>Code </summary>
</details>
<!--Complexity Analysis-->
<details>
  <summary> Complexity Analysis</summary>
</details>
</details>
<!--Find the largest and second largest element in a array-->
<details>
<summary>
  <h4> Find the largest and second largest element </h4>
</summary>
</details>
<!--Examples-->
<details>
  <summary>Examples</summary>
</details>
<!--Brute Force Approach-->
<details>
<summary>Brute Force Approach</summary>
<!--Approach-->
<details>
<summary>Approach/Intuition</summary>
</details>
<!--Dry Run-->
  <details>
  <summary>Dry Run</summary>
  </details>
<!--Code-->
<details>
  <summary>Code</summary>
</details>
<!--Complexity Analysis --><details>
  <summary> Complexity Analysis</summary>
</details>
</details>
</div>
</details>
<h4>Reverse the original array by 2 pointer Algorithm:</h4>
<pre><code>int main(){
  int arr[] = {1,2,3,4,5,6,7};
 int sz =7;
  int start=0,end= 6;
  while(start&lt;=end){
    swap(arr[start],arr[end]);
    start++;
    end--;
  }
  for(int i=0;i&lt;sz;i++){
    cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;
  }
  return 0;l
}
</code></pre>
<h3>Linear search Algorithm Questions : Given a array with a target we have to search that target in the array.</h3>
<p>.</p>
<pre><code>// Find the Largest element and second largest element 
void le(int arr[]){
  // Initialise the largest element and second largest element as int min
  int maxi=INT_MIN;
  int smaxi=INT_MIN;
  // Loop for finding the largest element
  for(int i=0; i&lt;5; i++){
    if(arr[i]&gt;maxi){
      maxi=arr[i];
    }
  }
  //Loop for finding the second largest element. I think we can use the same loop for finding the second largest element but we can't use because largest element is not calculated.
  for(int i=0; i&lt;5; i++){
    if(arr[i]&gt;smaxi &amp;&amp; arr[i]!=maxi){
     smaxi=arr[i];
    }
  }
  cout&lt;&lt;maxi&lt;&lt;endl;
  cout&lt;&lt;smaxi;
}
int main(){
  int arr[5]={12, 35, 1, 10, 3};
  le(arr);
  return 0;
}

</code></pre>
